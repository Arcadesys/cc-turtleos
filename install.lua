-- TurtleOS Installer
print('Installing TurtleOS...')

local files = {
    ['boot.lua'] = "-- boot.lua\r\n-- This file should be renamed to startup.lua on the turtle or called by it.\r\n\r\n-- Add the root directory to the package path so we can require files relative to root\r\npackage.path = \"/?.lua;/?/init.lua;\" .. package.path\r\n\r\nlocal core = require(\"turtleos.lib.core\")\r\n\r\nprint(\"Booting TurtleOS...\")\r\ncore.init()\r\n",
    ['turtleos/menu.lua'] = "local strategies_dir = \"turtleos/strategies\"\r\n\r\n-- Helper: Get list of roles (directories)\r\nlocal function get_roles()\r\n    local roles = {}\r\n    local files = fs.list(strategies_dir)\r\n    for _, file in ipairs(files) do\r\n        if fs.isDir(fs.combine(strategies_dir, file)) then\r\n            table.insert(roles, file)\r\n        end\r\n    end\r\n    table.sort(roles)\r\n    return roles\r\nend\r\n\r\n-- Helper: Get list of strategies for a role\r\nlocal function get_strategies(role)\r\n    local strats = {}\r\n    local path = fs.combine(strategies_dir, role)\r\n    if fs.exists(path) and fs.isDir(path) then\r\n        local files = fs.list(path)\r\n        for _, file in ipairs(files) do\r\n            if file:sub(-4) == \".lua\" then\r\n                table.insert(strats, file:sub(1, -5)) -- Remove .lua\r\n            end\r\n        end\r\n    end\r\n    table.sort(strats)\r\n    return strats\r\nend\r\n\r\nlocal function draw_menu(title, options, selected)\r\n    term.clear()\r\n    term.setCursorPos(1, 1)\r\n    textutils.slowPrint(title, 50) -- Nice little effect, very fast\r\n    print(string.rep(\"-\", #title))\r\n    \r\n    local w, h = term.getSize()\r\n    local start_y = 3\r\n    local max_items = h - start_y\r\n    \r\n    -- Pagination start index\r\n    local start_idx = 1\r\n    if selected > max_items then\r\n        start_idx = selected - max_items + 1\r\n    end\r\n\r\n    for i = 0, max_items - 1 do\r\n        local idx = start_idx + i\r\n        if idx > #options then break end\r\n        \r\n        term.setCursorPos(1, start_y + i)\r\n        local prefix = (idx == selected) and \"> \" or \"  \"\r\n        print(prefix .. options[idx].label)\r\n    end\r\nend\r\n\r\nlocal function run_menu()\r\n    local state = \"main\" -- main, role\r\n    local current_role = nil\r\n    \r\n    local main_selected = 1\r\n    local role_selected = 1\r\n    \r\n    while true do\r\n        local options = {}\r\n        local title = \"\"\r\n        local selected_ptr = 1\r\n        \r\n        if state == \"main\" then\r\n            title = \"Start Menu (Select Role)\"\r\n            local roles = get_roles()\r\n            for _, r in ipairs(roles) do\r\n                table.insert(options, {label = r:gsub(\"^%l\", string.upper), value = r, type = \"role\"})\r\n            end\r\n            table.insert(options, {label = \"Reboot\", type = \"cmd\", action = os.reboot})\r\n            table.insert(options, {label = \"Shutdown\", type = \"cmd\", action = os.shutdown})\r\n            \r\n            selected_ptr = main_selected\r\n            \r\n        elseif state == \"role\" then\r\n            title = \"Role: \" .. current_role:gsub(\"^%l\", string.upper)\r\n            local strats = get_strategies(current_role)\r\n            for _, s in ipairs(strats) do\r\n                table.insert(options, {label = s, value = s, type = \"strat\"})\r\n            end\r\n            table.insert(options, {label = \"< Back\", type = \"back\"})\r\n            \r\n            selected_ptr = role_selected\r\n        end\r\n        \r\n        draw_menu(title, options, selected_ptr)\r\n        \r\n        local event, key = os.pullEvent(\"key\")\r\n        \r\n        if key == keys.up then\r\n            selected_ptr = selected_ptr - 1\r\n            if selected_ptr < 1 then selected_ptr = #options end\r\n        elseif key == keys.down then\r\n            selected_ptr = selected_ptr + 1\r\n            if selected_ptr > #options then selected_ptr = 1 end\r\n        elseif key == keys.enter then\r\n            local action = options[selected_ptr]\r\n            \r\n            if state == \"main\" then\r\n                main_selected = selected_ptr\r\n                if action.type == \"role\" then\r\n                    current_role = action.value\r\n                    role_selected = 1\r\n                    state = \"role\"\r\n                elseif action.type == \"cmd\" then\r\n                    term.clear()\r\n                    term.setCursorPos(1,1)\r\n                    print(\"Executing...\")\r\n                    action.action()\r\n                end\r\n                \r\n            elseif state == \"role\" then\r\n                role_selected = selected_ptr\r\n                if action.type == \"back\" then\r\n                    state = \"main\"\r\n                elseif action.type == \"strat\" then\r\n                    term.clear()\r\n                    term.setCursorPos(1, 1)\r\n                    print(\"Running strategy: \" .. action.value)\r\n                    \r\n                    local script_path = fs.combine(strategies_dir, current_role, action.value .. \".lua\")\r\n                    -- Execute\r\n                    -- We can shell.run, but we need to consider arguments if ever needed.\r\n                    -- Ideally, strategies should be self-contained or use a runner.\r\n                    -- Looking at farmer.lua role, it requires and runs. \r\n                    -- But standalone execution via menu implies shell.run.\r\n                    shell.run(script_path)\r\n                    \r\n                    print(\"\\nProcess ended. Press any key to return.\")\r\n                    os.pullEvent(\"key\")\r\n                end\r\n            end\r\n        end\r\n        \r\n        -- Update the persisted selection pointers\r\n        if state == \"main\" then main_selected = selected_ptr\r\n        elseif state == \"role\" then role_selected = selected_ptr end\r\n    end\r\nend\r\n\r\nrun_menu()\r\n",
    ['turtleos/apis/movement.lua'] = "-- turtleos/apis/movement.lua\r\n-- Movement State Machine API for ComputerCraft Turtles\r\n-- Access via: local movement = require(\"turtleos.apis.movement\")\r\n\r\nlocal movement = {}\r\n\r\n-- State tracking\r\nlocal position = {x = 0, y = 0, z = 0}\r\nlocal facing = 0  -- 0=North(+Z), 1=East(+X), 2=South(-Z), 3=West(-X)\r\nlocal moveAttempts = 3\r\nlocal fuelThreshold = 100\r\n\r\n-- Movement states\r\nlocal STATE = {\r\n    IDLE = \"idle\",\r\n    MOVING = \"moving\",\r\n    BLOCKED = \"blocked\",\r\n    ATTACKING = \"attacking\",\r\n    LOW_FUEL = \"low_fuel\"\r\n}\r\n\r\nlocal currentState = STATE.IDLE\r\n\r\n-- Direction vectors for each facing\r\nlocal DIRECTIONS = {\r\n    [0] = {x = 0, z = 1},   -- North\r\n    [1] = {x = 1, z = 0},   -- East\r\n    [2] = {x = 0, z = -1},  -- South\r\n    [3] = {x = -1, z = 0}   -- West\r\n}\r\n\r\n-- Get current position\r\nfunction movement.getPosition()\r\n    return {x = position.x, y = position.y, z = position.z}\r\nend\r\n\r\n-- Get current facing direction\r\nfunction movement.getFacing()\r\n    return facing\r\nend\r\n\r\n-- Get current state\r\nfunction movement.getState()\r\n    return currentState\r\nend\r\n\r\n-- Set position (useful for calibration)\r\nfunction movement.setPosition(x, y, z)\r\n    position.x = x or position.x\r\n    position.y = y or position.y\r\n    position.z = z or position.z\r\n    movement.saveState()\r\nend\r\n\r\n-- Set facing direction\r\nfunction movement.setFacing(dir)\r\n    facing = dir % 4\r\n    movement.saveState()\r\nend\r\n\r\n-- Check fuel level\r\nfunction movement.checkFuel()\r\n    local level = turtle.getFuelLevel()\r\n    if level == \"unlimited\" then\r\n        return true\r\n    end\r\n    \r\n    while level < fuelThreshold do\r\n        currentState = STATE.LOW_FUEL\r\n        \r\n        -- Try to refuel from all slots\r\n        for i = 1, 16 do\r\n            turtle.select(i)\r\n            if turtle.refuel(0) then\r\n                turtle.refuel()\r\n            end\r\n        end\r\n        \r\n        level = turtle.getFuelLevel()\r\n        if level >= fuelThreshold then\r\n            break\r\n        end\r\n        \r\n        print(\"Fuel low (\" .. level .. \"/\" .. fuelThreshold .. \"). Waiting for assistance.\")\r\n        print(\"Press any key to retry...\")\r\n        os.pullEvent(\"key\")\r\n    end\r\n    \r\n    if currentState == STATE.LOW_FUEL then\r\n        currentState = STATE.IDLE\r\n    end\r\n    return true\r\nend\r\n\r\n-- Try to refuel from inventory\r\nfunction movement.refuel(amount)\r\n    amount = amount or 64\r\n    for slot = 1, 16 do\r\n        if turtle.getItemCount(slot) > 0 then\r\n            turtle.select(slot)\r\n            if turtle.refuel(1) then\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn right\r\nfunction movement.turnRight()\r\n    if turtle.turnRight() then\r\n        facing = (facing + 1) % 4\r\n        movement.saveState()\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn left\r\nfunction movement.turnLeft()\r\n    if turtle.turnLeft() then\r\n        facing = (facing - 1) % 4\r\n        movement.saveState()\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn around\r\nfunction movement.turnAround()\r\n    movement.turnRight()\r\n    movement.turnRight()\r\n    return true\r\nend\r\n\r\n-- Face a specific direction (0-3)\r\nfunction movement.face(dir)\r\n    dir = dir % 4\r\n    while facing ~= dir do\r\n        movement.turnRight()\r\n    end\r\n    return true\r\nend\r\n\r\n-- Forward movement with retry logic\r\nfunction movement.forward(force)\r\n    if not movement.checkFuel() then\r\n        print(\"[MOVEMENT] Failed: low fuel\")\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    print(string.format(\"[MOVEMENT] Attempting forward (facing=%d, pos=%d,%d,%d)\", facing, position.x, position.y, position.z))\r\n    \r\n    while attempts < moveAttempts do\r\n        local result = turtle.forward()\r\n        print(string.format(\"[MOVEMENT] turtle.forward() attempt %d: %s\", attempts + 1, tostring(result)))\r\n        \r\n        if result then\r\n            -- Update position\r\n            local dir = DIRECTIONS[facing]\r\n            position.x = position.x + dir.x\r\n            position.z = position.z + dir.z\r\n            print(string.format(\"[MOVEMENT] Success! New pos=%d,%d,%d\", position.x, position.y, position.z))\r\n            currentState = STATE.IDLE\r\n            movement.saveState()\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            -- Try to clear the way\r\n            if turtle.detect() then\r\n                print(\"[MOVEMENT] Block detected, digging...\")\r\n                currentState = STATE.BLOCKED\r\n                turtle.dig()\r\n                sleep(0.5)\r\n            elseif turtle.attack() then\r\n                print(\"[MOVEMENT] Entity detected, attacking...\")\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            else\r\n                print(\"[MOVEMENT] Path blocked but nothing to clear\")\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    print(\"[MOVEMENT] Failed after all attempts\")\r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Backward movement\r\nfunction movement.back()\r\n    if not movement.checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    \r\n    if turtle.back() then\r\n        -- Update position (move opposite of facing)\r\n        local dir = DIRECTIONS[facing]\r\n        position.x = position.x - dir.x\r\n        position.z = position.z - dir.z\r\n        currentState = STATE.IDLE\r\n        movement.saveState()\r\n        return true\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Up movement with retry logic\r\nfunction movement.up(force)\r\n    if not movement.checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.up() then\r\n            position.y = position.y + 1\r\n            currentState = STATE.IDLE\r\n            movement.saveState()\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectUp() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digUp()\r\n                sleep(0.5)\r\n            elseif turtle.attackUp() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Down movement with retry logic\r\nfunction movement.down(force)\r\n    if not movement.checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.down() then\r\n            position.y = position.y - 1\r\n            currentState = STATE.IDLE\r\n            movement.saveState()\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectDown() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digDown()\r\n                sleep(0.5)\r\n            elseif turtle.attackDown() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Go to a specific position (simple pathfinding)\r\nfunction movement.gotoPosition(targetX, targetY, targetZ, force)\r\n    force = force or false\r\n    \r\n    -- Move in X axis\r\n    while position.x ~= targetX do\r\n        if position.x < targetX then\r\n            movement.face(1)  -- East\r\n        else\r\n            movement.face(3)  -- West\r\n        end\r\n        \r\n        local success, err = movement.forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Z axis\r\n    while position.z ~= targetZ do\r\n        if position.z < targetZ then\r\n            movement.face(0)  -- North\r\n        else\r\n            movement.face(2)  -- South\r\n        end\r\n        \r\n        local success, err = movement.forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Y axis\r\n    while position.y ~= targetY do\r\n        local success, err\r\n        if position.y < targetY then\r\n            success, err = movement.up(force)\r\n        else\r\n            success, err = movement.down(force)\r\n        end\r\n        \r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    return true\r\nend\r\n\r\n-- Return to origin (0, 0, 0)\r\nfunction movement.home(force)\r\n    return movement.gotoPosition(0, 0, 0, force)\r\nend\r\n\r\n-- Get distance to a position\r\nfunction movement.distanceTo(x, y, z)\r\n    local dx = math.abs(position.x - x)\r\n    local dy = math.abs(position.y - y)\r\n    local dz = math.abs(position.z - z)\r\n    return dx + dy + dz  -- Manhattan distance\r\nend\r\n\r\n-- Configure movement parameters\r\nfunction movement.configure(config)\r\n    if config.moveAttempts then\r\n        moveAttempts = config.moveAttempts\r\n    end\r\n    if config.fuelThreshold then\r\n        fuelThreshold = config.fuelThreshold\r\n    end\r\nend\r\n\r\n-- Reset position and facing\r\nfunction movement.reset()\r\n    position = {x = 0, y = 0, z = 0}\r\n    facing = 0\r\n    currentState = STATE.IDLE\r\nend\r\n\r\n-- Save state to file\r\nfunction movement.saveState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    local file = fs.open(filename, \"w\")\r\n    if file then\r\n        file.writeLine(textutils.serialize({\r\n            position = position,\r\n            facing = facing\r\n        }))\r\n        file.close()\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Load state from file\r\nfunction movement.loadState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    if fs.exists(filename) then\r\n        local file = fs.open(filename, \"r\")\r\n        if file then\r\n            local data = textutils.unserialize(file.readAll())\r\n            file.close()\r\n            if data then\r\n                position = data.position or {x = 0, y = 0, z = 0}\r\n                facing = data.facing or 0\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nreturn movement\r\n",
    ['turtleos/apis/README.md'] = "# TurtleOS APIs\r\n\r\nThis directory contains ComputerCraft API modules for TurtleOS.\r\n\r\n## Movement API\r\n\r\nA state machine-based movement system for tracking turtle position, orientation, and handling intelligent movement with retry logic.\r\n\r\n### Loading the API\r\n\r\n```lua\r\nos.loadAPI(\"turtleos/apis/movement.lua\")\r\n```\r\n\r\n### Usage Examples\r\n\r\n```lua\r\n-- Basic movement\r\nmovement.forward(true)  -- Move forward, force through obstacles\r\nmovement.up(false)      -- Move up without forcing\r\nmovement.turnRight()\r\nmovement.turnLeft()\r\n\r\n-- Position tracking\r\nlocal pos = movement.getPosition()\r\nprint(\"Position:\", pos.x, pos.y, pos.z)\r\nprint(\"Facing:\", movement.getFacing())  -- 0=North, 1=East, 2=South, 3=West\r\n\r\n-- Pathfinding\r\nmovement.gotoPosition(10, 5, -3, true)  -- Go to coordinates (10, 5, -3)\r\nmovement.home(true)                      -- Return to origin (0, 0, 0)\r\n\r\n-- State management\r\nprint(\"Current state:\", movement.getState())\r\nmovement.saveState(\"my_position.txt\")\r\nmovement.loadState(\"my_position.txt\")\r\n\r\n-- Configuration\r\nmovement.configure({\r\n    moveAttempts = 5,      -- Retry failed movements 5 times\r\n    fuelThreshold = 200    -- Warn when fuel < 200\r\n})\r\n\r\n-- Fuel management\r\nif not movement.checkFuel() then\r\n    movement.refuel(64)\r\nend\r\n\r\n-- Utility\r\nlocal distance = movement.distanceTo(10, 5, -3)\r\nprint(\"Distance to target:\", distance)\r\n```\r\n\r\n### API Functions\r\n\r\n#### Movement\r\n- `forward(force)` - Move forward, optionally breaking blocks\r\n- `back()` - Move backward\r\n- `up(force)` - Move up, optionally breaking blocks\r\n- `down(force)` - Move down, optionally breaking blocks\r\n- `turnRight()` - Turn 90Â° clockwise\r\n- `turnLeft()` - Turn 90Â° counter-clockwise\r\n- `turnAround()` - Turn 180Â°\r\n- `face(direction)` - Face a specific direction (0-3)\r\n\r\n#### Navigation\r\n- `gotoPosition(x, y, z, force)` - Navigate to coordinates\r\n- `home(force)` - Return to origin (0, 0, 0)\r\n- `distanceTo(x, y, z)` - Calculate Manhattan distance\r\n\r\n#### State Management\r\n- `getPosition()` - Get current {x, y, z} coordinates\r\n- `getFacing()` - Get current facing direction (0-3)\r\n- `getState()` - Get current state (idle, moving, blocked, etc.)\r\n- `setPosition(x, y, z)` - Manually set position\r\n- `setFacing(direction)` - Manually set facing\r\n- `reset()` - Reset to origin\r\n\r\n#### Fuel\r\n- `checkFuel()` - Check if fuel is above threshold\r\n- `refuel(amount)` - Attempt to refuel from inventory\r\n\r\n#### Configuration\r\n- `configure(config)` - Set moveAttempts and fuelThreshold\r\n- `saveState(filename)` - Save position/facing to file\r\n- `loadState(filename)` - Load position/facing from file\r\n\r\n### States\r\n\r\nThe movement API tracks these states:\r\n- `idle` - Not currently moving\r\n- `moving` - In motion\r\n- `blocked` - Path is blocked\r\n- `attacking` - Clearing hostile mobs\r\n- `low_fuel` - Fuel below threshold\r\n",
    ['turtleos/lib/core.lua'] = "-- turtleos/lib/core.lua\r\nlocal schema = require(\"turtleos.lib.schema\")\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal core = {}\r\n\r\nlocal function checkAndRefuel()\r\n    if not turtle then\r\n        logger.warn(\"Not running on a turtle, skipping fuel check.\")\r\n        return\r\n    end\r\n\r\n    local MIN_FUEL = 100\r\n\r\n    while true do\r\n        logger.info(\"Checking fuel levels...\")\r\n        local level = turtle.getFuelLevel()\r\n        if level == \"unlimited\" then\r\n            logger.info(\"Fuel level: Unlimited\")\r\n            return\r\n        end\r\n\r\n        logger.info(\"Current Fuel: \" .. level)\r\n\r\n        for i = 1, 16 do\r\n            turtle.select(i)\r\n            if turtle.refuel(0) then\r\n                turtle.refuel()\r\n                logger.info(\"Refueled from slot \" .. i)\r\n            end\r\n        end\r\n        \r\n        level = turtle.getFuelLevel()\r\n        logger.info(\"New Fuel Level: \" .. level)\r\n\r\n        if level >= MIN_FUEL then\r\n            break\r\n        end\r\n\r\n        logger.warn(\"Fuel low (\" .. level .. \"/\" .. MIN_FUEL .. \"). Waiting for assistance.\")\r\n        print(\"Press any key to retry...\")\r\n        os.pullEvent(\"key\")\r\n    end\r\nend\r\n\r\nfunction core.init()\r\n    logger.info(\"TurtleOS initializing...\")\r\n    \r\n    checkAndRefuel()\r\n    \r\n    -- Load schema\r\n    local schemaData, err = schema.load(\"turtle_schema.json\")\r\n    if not schemaData then\r\n        if err and string.find(err, \"Schema file not found\") then\r\n            logger.warn(\"Schema not found. Creating default configuration...\")\r\n            local defaultSchema = {\r\n                name = \"Default Farmer\",\r\n                version = \"1.0.0\",\r\n                role = \"farmer\",\r\n                strategy = \"potato\"\r\n            }\r\n            local file = fs.open(\"turtle_schema.json\", \"w\")\r\n            file.write(textutils.serializeJSON(defaultSchema))\r\n            file.close()\r\n            \r\n            -- Retry load\r\n            schemaData, err = schema.load(\"turtle_schema.json\")\r\n        end\r\n\r\n        if not schemaData then\r\n            logger.error(\"Failed to load schema: \" .. (err or \"unknown error\"))\r\n            return false\r\n        end\r\n    end\r\n\r\n    logger.info(\"Loaded schema for: \" .. (schemaData.name or \"Unknown Turtle\"))\r\n    \r\n    -- Interactive Menu Access\r\n    print(\"Press 'm' or 'c' for MENU (3s)...\")\r\n    local timerId = os.startTimer(3)\r\n    local launchMenu = false\r\n    while true do\r\n        local event, p1 = os.pullEvent()\r\n        if event == \"timer\" and p1 == timerId then\r\n            break\r\n        elseif event == \"char\" and (p1 == \"m\" or p1 == \"c\") then\r\n            launchMenu = true\r\n            break\r\n        end\r\n    end\r\n    \r\n    if launchMenu then\r\n        logger.info(\"Launching Main Menu...\")\r\n        shell.run(\"turtleos/menu.lua\")\r\n        -- If menu returns (it loops, but just in case), we verify if we should continue\r\n        print(\"Menu exited. Resuming boot sequence in 3s...\")\r\n        sleep(3)\r\n    end\r\n\r\n    -- Determine role\r\n    local role = schemaData.role\r\n    if not role then\r\n        logger.error(\"No role defined in schema\")\r\n        return false\r\n    end\r\n\r\n    logger.info(\"Role: \" .. role)\r\n\r\n    -- Load role module\r\n    local rolePath = \"turtleos.roles.\" .. role\r\n    local success, roleModule = pcall(require, rolePath)\r\n    \r\n    if not success then\r\n        logger.error(\"Failed to load role module: \" .. rolePath)\r\n        logger.error(roleModule) -- Error message\r\n        return false\r\n    end\r\n\r\n    -- Execute role\r\n    if roleModule.run then\r\n        roleModule.run(schemaData)\r\n    else\r\n        logger.error(\"Role module missing 'run' function\")\r\n        return false\r\n    end\r\n\r\n    return true\r\nend\r\n\r\nreturn core\r\n",
    ['turtleos/lib/logger.lua'] = "-- turtleos/lib/logger.lua\r\n\r\nlocal logger = {}\r\n\r\nfunction logger.log(message)\r\n    print(\"[LOG] \" .. message)\r\n    -- In a real implementation, we might write to a file\r\nend\r\n\r\nfunction logger.error(message)\r\n    printError(\"[ERROR] \" .. message)\r\nend\r\n\r\nfunction logger.warn(message)\r\n    print(\"[WARN] \" .. message)\r\nend\r\n\r\nfunction logger.info(message)\r\n    print(\"[INFO] \" .. message)\r\nend\r\n\r\nreturn logger\r\n",
    ['turtleos/lib/schema.lua'] = "-- turtleos/lib/schema.lua\r\n\r\nlocal schema = {}\r\n\r\nfunction schema.load(path)\r\n    if not fs.exists(path) then\r\n        return nil, \"Schema file not found: \" .. path\r\n    end\r\n\r\n    local file = fs.open(path, \"r\")\r\n    local content = file.readAll()\r\n    file.close()\r\n\r\n    local data = textutils.unserializeJSON(content)\r\n    if not data then\r\n        return nil, \"Failed to parse schema JSON\"\r\n    end\r\n\r\n    return data\r\nend\r\n\r\nreturn schema\r\n",
    ['turtleos/roles/builder.lua'] = "-- turtleos/roles/builder.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal builder = {}\r\n\r\nfunction builder.run(schema)\r\n    logger.info(\"Starting Builder Role...\")\r\n    -- Builder logic here\r\n    -- Might load a blueprint from schema\r\nend\r\n\r\nreturn builder\r\n",
    ['turtleos/roles/farmer.lua'] = "-- turtleos/roles/farmer.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal farmer = {}\r\n\r\nfunction farmer.run(schema)\r\n    logger.info(\"Starting Farmer Role...\")\r\n    \r\n    local strategyName = schema.strategy\r\n    if not strategyName then\r\n        logger.error(\"No strategy defined for Farmer\")\r\n        return\r\n    end\r\n\r\n    local strategyPath = \"turtleos.strategies.farmer.\" .. strategyName\r\n    local success, strategy = pcall(require, strategyPath)\r\n\r\n    if not success then\r\n        logger.error(\"Failed to load strategy: \" .. strategyPath)\r\n        logger.error(strategy)\r\n        return\r\n    end\r\n\r\n    logger.info(\"Executing strategy: \" .. strategyName)\r\n    \r\n    while true do\r\n        if strategy.execute then\r\n            strategy.execute(schema)\r\n        else\r\n            logger.error(\"Strategy missing 'execute' function\")\r\n            break\r\n        end\r\n        sleep(1) -- Prevent infinite loop crash if strategy is instant\r\n    end\r\nend\r\n\r\nreturn farmer\r\n",
    ['turtleos/roles/miner.lua'] = "-- turtleos/roles/miner.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal miner = {}\r\n\r\nfunction miner.run(schema)\r\n    logger.info(\"Starting Miner Role...\")\r\n    -- Miner logic here\r\nend\r\n\r\nreturn miner\r\n",
    ['turtleos/strategies/farmer/potato.lua'] = "local logger = require(\"turtleos.lib.logger\")\r\nlocal movement = require(\"turtleos.apis.movement\")\r\n\r\nlocal potato = {}\r\nlocal initialized = false\r\n\r\n-- Runtime state\r\nlocal config = {\r\n    width = 9,\r\n    length = 9,\r\n    trash_items = {}\r\n}\r\n\r\n-- Helper Functions\r\nlocal function selectItem(name)\r\n    for i = 1, 16 do\r\n        local item = turtle.getItemDetail(i)\r\n        if item and item.name == name then\r\n            turtle.select(i)\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nlocal function selectHoe()\r\n    for i = 1, 16 do\r\n        local item = turtle.getItemDetail(i)\r\n        if item and item.name:find(\"hoe\") then\r\n            turtle.select(i)\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nlocal function hasSpace()\r\n    for i = 1, 16 do\r\n        if turtle.getItemCount(i) == 0 then return true end\r\n        local item = turtle.getItemDetail(i)\r\n        if item and item.name == \"minecraft:potato\" and turtle.getItemSpace(i) > 0 then\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nlocal function cleanupInventory()\r\n    for i = 1, 16 do\r\n        local item = turtle.getItemDetail(i)\r\n        if item and config.trash_items[item.name] then\r\n            turtle.select(i)\r\n            turtle.drop()\r\n        end\r\n    end\r\nend\r\n\r\n-- Atomic Operations\r\nlocal function selectEmptySlot()\r\n    for i = 1, 16 do\r\n        if turtle.getItemCount(i) == 0 then\r\n            turtle.select(i)\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\n-- Atomic Operations\r\nlocal operations = {}\r\n\r\noperations.harvest = function()\r\n    if not hasSpace() then\r\n        cleanupInventory()\r\n        if not hasSpace() then\r\n            logger.warn(\"Inventory full, cannot harvest\")\r\n            return false\r\n        end\r\n    end\r\n    turtle.digDown()\r\n    turtle.suckDown()\r\n    return true\r\nend\r\n\r\noperations.replant = function()\r\n    -- Forward to plant\r\n    return operations.plant()\r\nend\r\n\r\noperations.till = function()\r\n    -- Priority 1: Use Hoe in Inventory\r\n    if selectHoe() then\r\n        return turtle.placeDown()\r\n    end\r\n    \r\n    -- Priority 2: Use Equipped Hoe (requires empty slot selected)\r\n    if selectEmptySlot() then\r\n        if turtle.placeDown() then\r\n            return true\r\n        end\r\n        -- Only warn if both failed, but hard to distinguish \"failed to till\" from \"no tool\".\r\n        -- Assuming if placeDown fails with empty slot, either no tool or invalid target.\r\n    end\r\n    \r\n    logger.warn(\"Till failed (No hoe in inventory/equipped, or invalid target)\")\r\n    return false\r\nend\r\n\r\noperations.plant = function()\r\n    if selectItem(\"minecraft:potato\") then\r\n        if turtle.placeDown() then\r\n            return true\r\n        else\r\n            -- Smart Plant Logic: Failed to plant? Maybe needs tilling.\r\n            logger.warn(\"Failed to plant. Attempting to till...\")\r\n            \r\n            -- Go down to till level\r\n            if movement.down() then\r\n                if operations.till() then\r\n                    logger.info(\"Tilled successfully.\")\r\n                else\r\n                    logger.warn(\"Failed to till.\")\r\n                end\r\n                \r\n                -- Go back up\r\n                if not movement.up() then\r\n                    logger.error(\"CRITICAL: Failed to return to flight height!\")\r\n                    return false\r\n                end\r\n                \r\n                -- Retry planting\r\n                if selectItem(\"minecraft:potato\") and turtle.placeDown() then\r\n                    logger.info(\"Retry planting successful.\")\r\n                    return true\r\n                end\r\n            end\r\n        end\r\n    end\r\n    \r\n    -- Check if we really have no potatoes\r\n    if turtle.getItemCount() == 0 then -- naive check, selectItem does better but logging here\r\n         logger.warn(\"No potatoes to plant or placement prevented.\")\r\n    end\r\n    return false\r\nend\r\n\r\n-- Action Executor\r\nlocal function executeAction(actionDef)\r\n    if actionDef.type == \"inspect_and_interact\" then\r\n        local hasBlock, data = turtle.inspectDown()\r\n        \r\n        -- Determine State\r\n        local state = \"missing\"\r\n        if hasBlock then\r\n            if data.name == actionDef.expect then\r\n                local propsMatch = true\r\n                if actionDef.properties then\r\n                    for k, v in pairs(actionDef.properties) do\r\n                        if not data.state or data.state[k] ~= v then\r\n                            propsMatch = false\r\n                            break\r\n                        end\r\n                    end\r\n                end\r\n                \r\n                if propsMatch then\r\n                    state = \"match\"\r\n                else\r\n                    state = \"wrong_props\" -- Correct block, wrong state (e.g. immature crop)\r\n                end\r\n            else\r\n                state = \"wrong\" -- Completely different block (e.g. weeds/dirt where crop should be)\r\n            end\r\n        end\r\n        \r\n        -- Execute Handlers\r\n        local opsToRun = {}\r\n        if state == \"match\" then opsToRun = actionDef.on_match or {}\r\n        elseif state == \"missing\" then opsToRun = actionDef.on_missing or {}\r\n        elseif state == \"wrong\" then opsToRun = actionDef.on_wrong or {}\r\n        elseif state == \"wrong_props\" then opsToRun = actionDef.on_wrong_props or {}\r\n        end\r\n        \r\n        for _, opName in ipairs(opsToRun) do\r\n            if operations[opName] then\r\n                operations[opName]()\r\n            else\r\n                logger.error(\"Unknown operation: \" .. opName)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nlocal function processTile(schema, typeName)\r\n    local tileDef = schema.tile_definitions and schema.tile_definitions[typeName]\r\n    if not tileDef then\r\n        logger.error(\"Undefined tile type: \" .. typeName)\r\n        return\r\n    end\r\n    \r\n    if tileDef.actions then\r\n        for _, action in ipairs(tileDef.actions) do\r\n            executeAction(action)\r\n        end\r\n    end\r\nend\r\n\r\n-- Main Execution Function\r\nfunction potato.execute(schema)\r\n    if not schema or not schema.farm_config then\r\n        logger.error(\"Invalid schema provided to potato strategy\")\r\n        sleep(5)\r\n        return\r\n    end\r\n\r\n    -- Setup Config\r\n    config.width = schema.farm_config.dimensions.width or 9\r\n    config.length = schema.farm_config.dimensions.length or 9\r\n    \r\n    config.trash_items = {}\r\n    if schema.farm_config.trash_items then\r\n        for _, item in ipairs(schema.farm_config.trash_items) do\r\n            config.trash_items[item] = true\r\n        end\r\n    end\r\n    \r\n    -- Enforce start state (User guarantees placement)\r\n    logger.info(\"Calibrating position to (1, 1, 1) Facing North\")\r\n    movement.setPosition(1, 1, 1)\r\n    movement.setFacing(0)\r\n    movement.saveState()\r\n    \r\n    -- Interpret Plan\r\n    if schema.plan == \"fill_farm_space\" then\r\n        logger.info(\"Executing plan: fill_farm_space (\" .. config.width .. \"x\" .. config.length .. \")\")\r\n        \r\n        -- Move up to hover height (y=2) to avoid trampling crops\r\n        movement.gotoPosition(1, 2, 1, false)\r\n\r\n        -- Snake Pattern\r\n        for z = 1, config.length do\r\n            local startX, endX, stepX\r\n            if z % 2 == 1 then\r\n                startX, endX, stepX = 1, config.width, 1\r\n                movement.face(1) -- East\r\n            else\r\n                startX, endX, stepX = config.width, 1, -1\r\n                movement.face(3) -- West\r\n            end\r\n            \r\n            for x = startX, endX, stepX do\r\n                -- Move to position at height 2\r\n                movement.gotoPosition(x, 2, z, false)\r\n                processTile(schema, \"farm_space\")\r\n                \r\n                -- Periodic cleanup\r\n                if turtle.getItemCount(16) > 0 then\r\n                    cleanupInventory()\r\n                end\r\n            end\r\n        end\r\n    else\r\n        logger.error(\"Unknown plan: \" .. tostring(schema.plan))\r\n    end\r\n    \r\n    logger.info(\"Farm cycle complete. Returning start.\")\r\n    movement.gotoPosition(1, 1, 1, false)\r\n    \r\n    -- Simple delay instead of complex logic provided in old file\r\n    logger.info(\"Waiting for growth...\")\r\n    sleep(60)\r\nend\r\n\r\nreturn potato\r\n",
    ['turtleos/strategies/farmer/tree.lua'] = "-- turtleos/strategies/farmer/tree.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\n-- Load movement API\r\nlocal movement = require(\"turtleos.apis.movement\")\r\n\r\nlocal tree = {}\r\n\r\n-- Configuration\r\nlocal FARM_ROWS = 4    -- Number of trees along X axis\r\nlocal FARM_COLS = 4    -- Number of trees along Z axis\r\nlocal SPACING_X = 2    -- Distance between tree rows\r\nlocal SPACING_Z = 2    -- Distance between trees in a row\r\nlocal START_X = 2      -- X coordinate of first tree row\r\nlocal START_Z = 1      -- Z coordinate of first tree in row\r\n\r\n-- Aisle behind the last tree row to safely cross X columns\r\nlocal AISLE_Z = START_Z + (FARM_COLS * SPACING_Z)\r\n\r\nlocal function generateTreeLocations()\r\n    local locs = {}\r\n    for x = 0, FARM_ROWS - 1 do\r\n        for z = 0, FARM_COLS - 1 do\r\n            table.insert(locs, {\r\n                x = START_X + (x * SPACING_X),\r\n                z = START_Z + (z * SPACING_Z)\r\n            })\r\n        end\r\n    end\r\n    return locs\r\nend\r\n\r\nlocal treeLocations = generateTreeLocations()\r\nlocal currentTreeIndex = 1\r\n\r\nlocal function selectItem(pattern)\r\n    for i = 1, 16 do\r\n        local item = turtle.getItemDetail(i)\r\n        if item and item.name:find(pattern) then\r\n            turtle.select(i)\r\n            return true\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\nlocal function isLog(name)\r\n    if not name then return false end\r\n    -- Match any type of log\r\n    return name:find(\"log\") ~= nil or name:find(\"wood\") ~= nil or name:find(\"stem\") ~= nil\r\nend\r\n\r\nlocal function isSapling(name)\r\n    if not name then return false end\r\n    return name:find(\"sapling\") ~= nil\r\nend\r\n\r\nlocal function isLeaves(name)\r\n    if not name then return false end\r\n    return name:find(\"leaves\") ~= nil or name:find(\"wart_block\") ~= nil\r\nend\r\n\r\n-- Comprehensive tree chopping that handles branches\r\nlocal function chopTree()\r\n    logger.info(\"Starting tree chop sequence...\")\r\n    local logsChopped = 0\r\n    \r\n    -- Dig the base log\r\n    if turtle.detect() then\r\n        local success, data = turtle.inspect()\r\n        if success then\r\n            logger.info(\"Base block: \" .. data.name)\r\n            if isLog(data.name) then\r\n                turtle.dig()\r\n                logsChopped = logsChopped + 1\r\n            else\r\n                logger.warn(\"Front block is not a log: \" .. data.name)\r\n                return 0\r\n            end\r\n        end\r\n    else\r\n        logger.warn(\"No block in front to chop\")\r\n        return 0\r\n    end\r\n    \r\n    -- Move forward into the tree position\r\n    if not movement.forward(true) then\r\n        logger.error(\"Failed to move into tree position\")\r\n        return logsChopped\r\n    end\r\n    \r\n    -- Chop upwards\r\n    local height = 0\r\n    while height < 32 do -- Max tree height limit\r\n        local hasUp, upData = turtle.inspectUp()\r\n        \r\n        if hasUp and (isLog(upData.name) or isLeaves(upData.name)) then\r\n            if isLog(upData.name) then\r\n                logger.info(\"Found log above at height \" .. height)\r\n                turtle.digUp()\r\n                logsChopped = logsChopped + 1\r\n            else\r\n                -- It's leaves, dig through them\r\n                turtle.digUp()\r\n            end\r\n            \r\n            if movement.up(true) then\r\n                height = height + 1\r\n            else\r\n                logger.warn(\"Failed to move up at height \" .. height)\r\n                break\r\n            end\r\n        else\r\n            -- No more logs/leaves above\r\n            break\r\n        end\r\n        \r\n        -- Check and dig logs in all horizontal directions at this level\r\n        for dir = 0, 3 do\r\n            movement.face(dir)\r\n            local hasFront, frontData = turtle.inspect()\r\n            if hasFront and isLog(frontData.name) then\r\n                logger.info(\"Found adjacent log at height \" .. height)\r\n                turtle.dig()\r\n                logsChopped = logsChopped + 1\r\n            end\r\n        end\r\n    end\r\n    \r\n    logger.info(\"Chopped \" .. logsChopped .. \" logs, descending from height \" .. height)\r\n    \r\n    -- Come back down\r\n    for i = 1, height do\r\n        if not movement.down(true) then\r\n            logger.error(\"Failed to descend at level \" .. i)\r\n            break\r\n        end\r\n    end\r\n    \r\n    -- Move back to standing position (back out of the tree)\r\n    -- We assume we approach from West (x-1), so we exit to West (3)\r\n    movement.face(3)\r\n    if not movement.forward(true) then\r\n        logger.error(\"Failed to exit tree position\")\r\n    end\r\n    \r\n    -- Face the tree again (East) for planting or next check\r\n    movement.face(1)\r\n    \r\n    return logsChopped\r\nend\r\n\r\n-- Move to a specific standing position safely\r\nlocal function safeGoto(targetX, targetZ)\r\n    local SAFE_HEIGHT = 2 -- Fly over chests/ground obstacles\r\n    local current = movement.getPosition()\r\n    \r\n    -- Function to ensure height\r\n    local function ensureHeight(h)\r\n        local pos = movement.getPosition()\r\n         -- Go Up\r\n        while pos.y < h do\r\n            if not movement.up(true) then return false end\r\n            pos = movement.getPosition()\r\n        end\r\n        -- Go Down (only if we need to go lower, but here we just want AT LEAST h)\r\n        return true\r\n    end\r\n\r\n    -- 1. Ascend to safe height\r\n    if not ensureHeight(SAFE_HEIGHT) then\r\n        logger.error(\"Failed to ascend to safe height\")\r\n        return false\r\n    end\r\n    \r\n    -- 2. Traverse logic\r\n    -- If changing columns, use the aisle at Z=9\r\n    if math.abs(current.x - targetX) > 0.1 then\r\n        -- Move to AISLE_Z (Back of the farm) at safe height\r\n        if not movement.gotoPosition(current.x, SAFE_HEIGHT, AISLE_Z, true) then\r\n            logger.error(\"Failed to move to safe aisle\")\r\n            return false\r\n        end\r\n        \r\n        -- Move along aisle to target X\r\n        if not movement.gotoPosition(targetX, SAFE_HEIGHT, AISLE_Z, true) then\r\n            logger.error(\"Failed to move along safe aisle\")\r\n            return false\r\n        end\r\n    end\r\n    \r\n    -- 3. Move to target tree Z at safe height\r\n    if not movement.gotoPosition(targetX, SAFE_HEIGHT, targetZ, true) then\r\n        logger.error(\"Failed to move to target Z\")\r\n        return false\r\n    end\r\n    \r\n    -- 4. Descend to ground (Target Y=0)\r\n    if not movement.gotoPosition(targetX, 0, targetZ, true) then\r\n        logger.error(\"Failed to descend to tree position\")\r\n        return false\r\n    end\r\n    \r\n    return true\r\nend\r\n\r\nlocal STATE_FILE = \"tree_state.txt\"\r\n\r\nlocal function saveProgress(index)\r\n    local file = fs.open(STATE_FILE, \"w\")\r\n    if file then\r\n        file.write(tostring(index))\r\n        file.close()\r\n    end\r\nend\r\n\r\nlocal function loadProgress()\r\n    if fs.exists(STATE_FILE) then\r\n        local file = fs.open(STATE_FILE, \"r\")\r\n        if file then\r\n            local data = file.readAll()\r\n            file.close()\r\n            return tonumber(data) or 1\r\n        end\r\n    end\r\n    return 1\r\nend\r\n\r\nfunction tree.execute()\r\n    -- Debug: Check if turtle API exists\r\n    if not turtle then\r\n        logger.error(\"Turtle API not available! Are you running this on a turtle?\")\r\n        return\r\n    end\r\n    \r\n    -- Load movement state\r\n    movement.loadState()\r\n    \r\n    -- Check fuel\r\n    local fuelLevel = turtle.getFuelLevel()\r\n    logger.info(\"Current fuel level: \" .. tostring(fuelLevel))\r\n    \r\n    if fuelLevel ~= \"unlimited\" and fuelLevel < 100 then\r\n        logger.info(\"Attempting to refuel...\")\r\n        movement.refuel()\r\n        logger.info(\"New fuel level: \" .. turtle.getFuelLevel())\r\n    end\r\n\r\n    -- Load progress\r\n    currentTreeIndex = loadProgress()\r\n    if currentTreeIndex > #treeLocations then\r\n        logger.warn(\"Saved index \" .. currentTreeIndex .. \" exceeds tree count \" .. #treeLocations .. \". Resetting to 1.\")\r\n        currentTreeIndex = 1\r\n    end\r\n    logger.info(\"Resuming from tree index \" .. currentTreeIndex)\r\n\r\n    -- Get current tree target\r\n    local targetTree = treeLocations[currentTreeIndex]\r\n    local standX = targetTree.x - 1\r\n    local standZ = targetTree.z\r\n    \r\n    logger.info(string.format(\"Moving to tree %d at (%d, %d)\", currentTreeIndex, targetTree.x, targetTree.z))\r\n    \r\n    -- Go to standing position\r\n    if not safeGoto(standX, standZ) then\r\n        logger.error(\"Aborting tree cycle due to movement error.\")\r\n        return\r\n    end\r\n    \r\n    -- Save position after successful move\r\n    movement.saveState()\r\n    \r\n    -- Face East (towards the tree at x+1)\r\n    movement.face(1)\r\n    movement.saveState()\r\n\r\n    local hasBlock, data = turtle.inspect()\r\n    \r\n    if hasBlock then\r\n        logger.info(\"Block detected: \" .. data.name)\r\n    else\r\n        logger.info(\"No block in front\")\r\n    end\r\n    \r\n    if hasBlock and isLog(data.name) then\r\n        logger.info(\"Found tree! Starting comprehensive chop...\")\r\n        local logsChopped = chopTree()\r\n        logger.info(\"Finished chopping! Total logs: \" .. logsChopped)\r\n        \r\n        -- Try to plant immediately after chopping\r\n        logger.info(\"Planting sapling...\")\r\n        if selectItem(\"sapling\") then\r\n            if turtle.place() then\r\n                logger.info(\"Sapling planted successfully\")\r\n            else\r\n                logger.warn(\"Failed to place sapling (something blocking?)\")\r\n            end\r\n        else\r\n            logger.warn(\"No saplings found in inventory!\")\r\n        end\r\n\r\n    elseif not hasBlock then\r\n        -- Space is empty, try to plant\r\n        logger.info(\"Space empty. Planting sapling...\")\r\n        if selectItem(\"sapling\") then\r\n            if not turtle.place() then\r\n                logger.warn(\"Failed to place sapling.\")\r\n            end\r\n        else\r\n            logger.warn(\"No saplings found in inventory!\")\r\n        end\r\n    else\r\n        -- Block exists but is not a log.\r\n        if isSapling(data.name) then\r\n             logger.info(\"Sapling detected, waiting for growth...\")\r\n        else\r\n             logger.warn(\"Unknown block in front: \" .. data.name)\r\n        end\r\n    end\r\n    \r\n    -- Move to next tree index for next execution\r\n    currentTreeIndex = currentTreeIndex + 1\r\n    if currentTreeIndex > #treeLocations then\r\n        currentTreeIndex = 1\r\n        logger.info(\"Cycle complete. Restarting...\")\r\n        sleep(5) -- Wait a bit before restarting the cycle\r\n    end\r\n    \r\n    -- Save progress for next run\r\n    saveProgress(currentTreeIndex)\r\nend\r\n\r\nreturn tree\r\n",
}

for path, content in pairs(files) do
    print("Writing " .. path)
    local dir = fs.getDir(path)
    if not fs.exists(dir) and dir ~= "" and dir ~= "." then
        fs.makeDir(dir)
    end
    
    local file = fs.open(path, "w")
    file.write(content)
    file.close()
end

if not fs.exists("startup.lua") then
    print("Creating startup.lua...")
    local file = fs.open("startup.lua", "w")
    file.write('shell.run("boot.lua")')
    file.close()
end

print("Installation complete. Rebooting in 3 seconds...")
sleep(3)
os.reboot()