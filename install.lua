-- TurtleOS Installer
print('Installing TurtleOS...')

local files = {
    ["boot.lua"] = "-- boot.lua\r\n-- This file should be renamed to startup.lua on the turtle or called by it.\r\n\r\n-- Add the root directory to the package path so we can require files relative to root\r\npackage.path = \"/?.lua;/?/init.lua;\" .. package.path\r\n\r\n-- Load APIs\r\nif fs.exists(\"turtleos/apis/movement.lua\") then\r\n    os.loadAPI(\"turtleos/apis/movement.lua\")\r\nend\r\n\r\nlocal core = require(\"turtleos.lib.core\")\r\n\r\nprint(\"Booting TurtleOS...\")\r\ncore.init()\r\n",
    ["turtleos/apis/movement.lua"] = "-- turtleos/apis/movement.lua\r\n-- Movement State Machine API for ComputerCraft Turtles\r\n-- Load with: os.loadAPI(\"turtleos/apis/movement.lua\")\r\n-- Access via: movement.forward(), movement.getPosition(), etc.\r\n\r\n-- State tracking\r\nlocal position = {x = 0, y = 0, z = 0}\r\nlocal facing = 0  -- 0=North(+Z), 1=East(+X), 2=South(-Z), 3=West(-X)\r\nlocal moveAttempts = 3\r\nlocal fuelThreshold = 100\r\n\r\n-- Movement states\r\nlocal STATE = {\r\n    IDLE = \"idle\",\r\n    MOVING = \"moving\",\r\n    BLOCKED = \"blocked\",\r\n    ATTACKING = \"attacking\",\r\n    LOW_FUEL = \"low_fuel\"\r\n}\r\n\r\nlocal currentState = STATE.IDLE\r\n\r\n-- Direction vectors for each facing\r\nlocal DIRECTIONS = {\r\n    [0] = {x = 0, z = 1},   -- North\r\n    [1] = {x = 1, z = 0},   -- East\r\n    [2] = {x = 0, z = -1},  -- South\r\n    [3] = {x = -1, z = 0}   -- West\r\n}\r\n\r\n-- Get current position\r\nfunction getPosition()\r\n    return {x = position.x, y = position.y, z = position.z}\r\nend\r\n\r\n-- Get current facing direction\r\nfunction getFacing()\r\n    return facing\r\nend\r\n\r\n-- Get current state\r\nfunction getState()\r\n    return currentState\r\nend\r\n\r\n-- Set position (useful for calibration)\r\nfunction setPosition(x, y, z)\r\n    position.x = x or position.x\r\n    position.y = y or position.y\r\n    position.z = z or position.z\r\nend\r\n\r\n-- Set facing direction\r\nfunction setFacing(dir)\r\n    facing = dir % 4\r\nend\r\n\r\n-- Check fuel level\r\nfunction checkFuel()\r\n    local level = turtle.getFuelLevel()\r\n    if level == \"unlimited\" then\r\n        return true\r\n    end\r\n    \r\n    if level < fuelThreshold then\r\n        currentState = STATE.LOW_FUEL\r\n        return false\r\n    end\r\n    return true\r\nend\r\n\r\n-- Try to refuel from inventory\r\nfunction refuel(amount)\r\n    amount = amount or 64\r\n    for slot = 1, 16 do\r\n        if turtle.getItemCount(slot) > 0 then\r\n            turtle.select(slot)\r\n            if turtle.refuel(1) then\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn right\r\nfunction turnRight()\r\n    if turtle.turnRight() then\r\n        facing = (facing + 1) % 4\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn left\r\nfunction turnLeft()\r\n    if turtle.turnLeft() then\r\n        facing = (facing - 1) % 4\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn around\r\nfunction turnAround()\r\n    turnRight()\r\n    turnRight()\r\n    return true\r\nend\r\n\r\n-- Face a specific direction (0-3)\r\nfunction face(dir)\r\n    dir = dir % 4\r\n    while facing ~= dir do\r\n        turnRight()\r\n    end\r\n    return true\r\nend\r\n\r\n-- Forward movement with retry logic\r\nfunction forward(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.forward() then\r\n            -- Update position\r\n            local dir = DIRECTIONS[facing]\r\n            position.x = position.x + dir.x\r\n            position.z = position.z + dir.z\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            -- Try to clear the way\r\n            if turtle.detect() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.dig()\r\n                sleep(0.5)\r\n            elseif turtle.attack() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Backward movement\r\nfunction back()\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    \r\n    if turtle.back() then\r\n        -- Update position (move opposite of facing)\r\n        local dir = DIRECTIONS[facing]\r\n        position.x = position.x - dir.x\r\n        position.z = position.z - dir.z\r\n        currentState = STATE.IDLE\r\n        return true\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Up movement with retry logic\r\nfunction up(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.up() then\r\n            position.y = position.y + 1\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectUp() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digUp()\r\n                sleep(0.5)\r\n            elseif turtle.attackUp() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Down movement with retry logic\r\nfunction down(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.down() then\r\n            position.y = position.y - 1\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectDown() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digDown()\r\n                sleep(0.5)\r\n            elseif turtle.attackDown() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Go to a specific position (simple pathfinding)\r\nfunction gotoPosition(targetX, targetY, targetZ, force)\r\n    force = force or false\r\n    \r\n    -- Move in X axis\r\n    while position.x ~= targetX do\r\n        if position.x < targetX then\r\n            face(1)  -- East\r\n        else\r\n            face(3)  -- West\r\n        end\r\n        \r\n        local success, err = forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Z axis\r\n    while position.z ~= targetZ do\r\n        if position.z < targetZ then\r\n            face(0)  -- North\r\n        else\r\n            face(2)  -- South\r\n        end\r\n        \r\n        local success, err = forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Y axis\r\n    while position.y ~= targetY do\r\n        local success, err\r\n        if position.y < targetY then\r\n            success, err = up(force)\r\n        else\r\n            success, err = down(force)\r\n        end\r\n        \r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    return true\r\nend\r\n\r\n-- Return to origin (0, 0, 0)\r\nfunction home(force)\r\n    return gotoPosition(0, 0, 0, force)\r\nend\r\n\r\n-- Get distance to a position\r\nfunction distanceTo(x, y, z)\r\n    local dx = math.abs(position.x - x)\r\n    local dy = math.abs(position.y - y)\r\n    local dz = math.abs(position.z - z)\r\n    return dx + dy + dz  -- Manhattan distance\r\nend\r\n\r\n-- Configure movement parameters\r\nfunction configure(config)\r\n    if config.moveAttempts then\r\n        moveAttempts = config.moveAttempts\r\n    end\r\n    if config.fuelThreshold then\r\n        fuelThreshold = config.fuelThreshold\r\n    end\r\nend\r\n\r\n-- Reset position and facing\r\nfunction reset()\r\n    position = {x = 0, y = 0, z = 0}\r\n    facing = 0\r\n    currentState = STATE.IDLE\r\nend\r\n\r\n-- Save state to file\r\nfunction saveState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    local file = fs.open(filename, \"w\")\r\n    if file then\r\n        file.writeLine(textutils.serialize({\r\n            position = position,\r\n            facing = facing\r\n        }))\r\n        file.close()\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Load state from file\r\nfunction loadState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    if fs.exists(filename) then\r\n        local file = fs.open(filename, \"r\")\r\n        if file then\r\n            local data = textutils.unserialize(file.readAll())\r\n            file.close()\r\n            if data then\r\n                position = data.position or {x = 0, y = 0, z = 0}\r\n                facing = data.facing or 0\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n",
    ["turtleos/apis/README.md"] = "# TurtleOS APIs\r\n\r\nThis directory contains ComputerCraft API modules for TurtleOS.\r\n\r\n## Movement API\r\n\r\nA state machine-based movement system for tracking turtle position, orientation, and handling intelligent movement with retry logic.\r\n\r\n### Loading the API\r\n\r\n```lua\r\nos.loadAPI(\"turtleos/apis/movement.lua\")\r\n```\r\n\r\n### Usage Examples\r\n\r\n```lua\r\n-- Basic movement\r\nmovement.forward(true)  -- Move forward, force through obstacles\r\nmovement.up(false)      -- Move up without forcing\r\nmovement.turnRight()\r\nmovement.turnLeft()\r\n\r\n-- Position tracking\r\nlocal pos = movement.getPosition()\r\nprint(\"Position:\", pos.x, pos.y, pos.z)\r\nprint(\"Facing:\", movement.getFacing())  -- 0=North, 1=East, 2=South, 3=West\r\n\r\n-- Pathfinding\r\nmovement.gotoPosition(10, 5, -3, true)  -- Go to coordinates (10, 5, -3)\r\nmovement.home(true)                      -- Return to origin (0, 0, 0)\r\n\r\n-- State management\r\nprint(\"Current state:\", movement.getState())\r\nmovement.saveState(\"my_position.txt\")\r\nmovement.loadState(\"my_position.txt\")\r\n\r\n-- Configuration\r\nmovement.configure({\r\n    moveAttempts = 5,      -- Retry failed movements 5 times\r\n    fuelThreshold = 200    -- Warn when fuel < 200\r\n})\r\n\r\n-- Fuel management\r\nif not movement.checkFuel() then\r\n    movement.refuel(64)\r\nend\r\n\r\n-- Utility\r\nlocal distance = movement.distanceTo(10, 5, -3)\r\nprint(\"Distance to target:\", distance)\r\n```\r\n\r\n### API Functions\r\n\r\n#### Movement\r\n- `forward(force)` - Move forward, optionally breaking blocks\r\n- `back()` - Move backward\r\n- `up(force)` - Move up, optionally breaking blocks\r\n- `down(force)` - Move down, optionally breaking blocks\r\n- `turnRight()` - Turn 90° clockwise\r\n- `turnLeft()` - Turn 90° counter-clockwise\r\n- `turnAround()` - Turn 180°\r\n- `face(direction)` - Face a specific direction (0-3)\r\n\r\n#### Navigation\r\n- `gotoPosition(x, y, z, force)` - Navigate to coordinates\r\n- `home(force)` - Return to origin (0, 0, 0)\r\n- `distanceTo(x, y, z)` - Calculate Manhattan distance\r\n\r\n#### State Management\r\n- `getPosition()` - Get current {x, y, z} coordinates\r\n- `getFacing()` - Get current facing direction (0-3)\r\n- `getState()` - Get current state (idle, moving, blocked, etc.)\r\n- `setPosition(x, y, z)` - Manually set position\r\n- `setFacing(direction)` - Manually set facing\r\n- `reset()` - Reset to origin\r\n\r\n#### Fuel\r\n- `checkFuel()` - Check if fuel is above threshold\r\n- `refuel(amount)` - Attempt to refuel from inventory\r\n\r\n#### Configuration\r\n- `configure(config)` - Set moveAttempts and fuelThreshold\r\n- `saveState(filename)` - Save position/facing to file\r\n- `loadState(filename)` - Load position/facing from file\r\n\r\n### States\r\n\r\nThe movement API tracks these states:\r\n- `idle` - Not currently moving\r\n- `moving` - In motion\r\n- `blocked` - Path is blocked\r\n- `attacking` - Clearing hostile mobs\r\n- `low_fuel` - Fuel below threshold\r\n",
    ["turtleos/lib/core.lua"] = "-- turtleos/lib/core.lua\r\nlocal schema = require(\"turtleos.lib.schema\")\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal core = {}\r\n\r\nlocal function checkAndRefuel()\r\n    if not turtle then\r\n        logger.warn(\"Not running on a turtle, skipping fuel check.\")\r\n        return\r\n    end\r\n\r\n    logger.info(\"Checking fuel levels...\")\r\n    local level = turtle.getFuelLevel()\r\n    if level == \"unlimited\" then\r\n        logger.info(\"Fuel level: Unlimited\")\r\n        return\r\n    end\r\n\r\n    logger.info(\"Current Fuel: \" .. level)\r\n\r\n    for i = 1, 16 do\r\n        turtle.select(i)\r\n        if turtle.refuel(0) then\r\n            turtle.refuel()\r\n            logger.info(\"Refueled from slot \" .. i)\r\n        end\r\n    end\r\n    \r\n    logger.info(\"New Fuel Level: \" .. turtle.getFuelLevel())\r\nend\r\n\r\nfunction core.init()\r\n    logger.info(\"TurtleOS initializing...\")\r\n    \r\n    checkAndRefuel()\r\n    \r\n    -- Load schema\r\n    local schemaData, err = schema.load(\"turtle_schema.json\")\r\n    if not schemaData then\r\n        if err and string.find(err, \"Schema file not found\") then\r\n            logger.warn(\"Schema not found. Creating default configuration...\")\r\n            local defaultSchema = {\r\n                name = \"Default Farmer\",\r\n                version = \"1.0.0\",\r\n                role = \"farmer\",\r\n                strategy = \"potato\"\r\n            }\r\n            local file = fs.open(\"turtle_schema.json\", \"w\")\r\n            file.write(textutils.serializeJSON(defaultSchema))\r\n            file.close()\r\n            \r\n            -- Retry load\r\n            schemaData, err = schema.load(\"turtle_schema.json\")\r\n        end\r\n\r\n        if not schemaData then\r\n            logger.error(\"Failed to load schema: \" .. (err or \"unknown error\"))\r\n            return false\r\n        end\r\n    end\r\n\r\n    logger.info(\"Loaded schema for: \" .. (schemaData.name or \"Unknown Turtle\"))\r\n\r\n    -- Determine role\r\n    local role = schemaData.role\r\n    if not role then\r\n        logger.error(\"No role defined in schema\")\r\n        return false\r\n    end\r\n\r\n    logger.info(\"Role: \" .. role)\r\n\r\n    -- Load role module\r\n    local rolePath = \"turtleos.roles.\" .. role\r\n    local success, roleModule = pcall(require, rolePath)\r\n    \r\n    if not success then\r\n        logger.error(\"Failed to load role module: \" .. rolePath)\r\n        logger.error(roleModule) -- Error message\r\n        return false\r\n    end\r\n\r\n    -- Execute role\r\n    if roleModule.run then\r\n        roleModule.run(schemaData)\r\n    else\r\n        logger.error(\"Role module missing 'run' function\")\r\n        return false\r\n    end\r\n\r\n    return true\r\nend\r\n\r\nreturn core\r\n",
    ["turtleos/lib/logger.lua"] = "-- turtleos/lib/logger.lua\r\n\r\nlocal logger = {}\r\n\r\nfunction logger.log(message)\r\n    print(\"[LOG] \" .. message)\r\n    -- In a real implementation, we might write to a file\r\nend\r\n\r\nfunction logger.error(message)\r\n    printError(\"[ERROR] \" .. message)\r\nend\r\n\r\nfunction logger.warn(message)\r\n    print(\"[WARN] \" .. message)\r\nend\r\n\r\nfunction logger.info(message)\r\n    print(\"[INFO] \" .. message)\r\nend\r\n\r\nreturn logger\r\n",
    ["turtleos/lib/schema.lua"] = "-- turtleos/lib/schema.lua\r\n\r\nlocal schema = {}\r\n\r\nfunction schema.load(path)\r\n    if not fs.exists(path) then\r\n        return nil, \"Schema file not found: \" .. path\r\n    end\r\n\r\n    local file = fs.open(path, \"r\")\r\n    local content = file.readAll()\r\n    file.close()\r\n\r\n    local data = textutils.unserializeJSON(content)\r\n    if not data then\r\n        return nil, \"Failed to parse schema JSON\"\r\n    end\r\n\r\n    return data\r\nend\r\n\r\nreturn schema\r\n",
    ["turtleos/roles/builder.lua"] = "-- turtleos/roles/builder.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal builder = {}\r\n\r\nfunction builder.run(schema)\r\n    logger.info(\"Starting Builder Role...\")\r\n    -- Builder logic here\r\n    -- Might load a blueprint from schema\r\nend\r\n\r\nreturn builder\r\n",
    ["turtleos/roles/farmer.lua"] = "-- turtleos/roles/farmer.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal farmer = {}\r\n\r\nfunction farmer.run(schema)\r\n    logger.info(\"Starting Farmer Role...\")\r\n    \r\n    local strategyName = schema.strategy\r\n    if not strategyName then\r\n        logger.error(\"No strategy defined for Farmer\")\r\n        return\r\n    end\r\n\r\n    local strategyPath = \"turtleos.strategies.farmer.\" .. strategyName\r\n    local success, strategy = pcall(require, strategyPath)\r\n\r\n    if not success then\r\n        logger.error(\"Failed to load strategy: \" .. strategyPath)\r\n        logger.error(strategy)\r\n        return\r\n    end\r\n\r\n    logger.info(\"Executing strategy: \" .. strategyName)\r\n    \r\n    while true do\r\n        if strategy.execute then\r\n            strategy.execute()\r\n        else\r\n            logger.error(\"Strategy missing 'execute' function\")\r\n            break\r\n        end\r\n        sleep(1) -- Prevent infinite loop crash if strategy is instant\r\n    end\r\nend\r\n\r\nreturn farmer\r\n",
    ["turtleos/roles/miner.lua"] = "-- turtleos/roles/miner.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal miner = {}\r\n\r\nfunction miner.run(schema)\r\n    logger.info(\"Starting Miner Role...\")\r\n    -- Miner logic here\r\nend\r\n\r\nreturn miner\r\n",
    ["turtleos/strategies/farmer/potato.lua"] = "-- turtleos/strategies/farmer/potato.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\n-- Ensure movement API is loaded\r\nif not movement then\r\n    os.loadAPI(\"turtleos/apis/movement.lua\")\r\nend\r\n\r\nlocal potato = {}\r\nlocal initialized = false\r\n\r\nfunction potato.execute()\r\n    -- 1. Initialization: Move to start offset (1, 1)\r\n    if not initialized then\r\n        logger.info(\"Initializing Farmer Strategy v2.1...\")\r\n        \r\n        -- Ensure we are hovering (Y=1) to avoid breaking crops or getting blocked\r\n        if movement.getPosition().y < 1 then\r\n             logger.info(\"Moving to hover height...\")\r\n             if not movement.up() then\r\n                 logger.error(\"Failed to move up!\")\r\n                 return\r\n             end\r\n        end\r\n\r\n        -- Move to offset (1, 1) relative to origin\r\n        -- Target: X=1, Z=1, Y=1\r\n        logger.info(\"Moving to start offset (1, 1)...\")\r\n        local success, err = movement.gotoPosition(1, 1, 1)\r\n        if not success then\r\n            logger.error(\"Failed to reach start position: \" .. (err or \"unknown\"))\r\n        else\r\n            logger.info(\"Reached start position.\")\r\n        end\r\n        \r\n        initialized = true\r\n        return\r\n    end\r\n\r\n    logger.info(\"Farming potatoes...\")\r\n\r\n    -- 2. Check fuel\r\n    if turtle.getFuelLevel() < 100 then\r\n        logger.warn(\"Low fuel! Attempting to refuel...\")\r\n        movement.refuel()\r\n    end\r\n\r\n    -- 3. Farm the block below\r\n    local hasCrop, cropData = turtle.inspectDown()\r\n    \r\n    if hasCrop and cropData.name == \"minecraft:potatoes\" then\r\n        if cropData.state.age == 7 then\r\n            logger.info(\"Harvesting potato below...\")\r\n            turtle.digDown()\r\n            turtle.suckDown() -- Collect extra drops\r\n            turtle.placeDown() -- Replant\r\n        else\r\n            -- logger.info(\"Waiting for potato to grow...\")\r\n        end\r\n    elseif not hasCrop then\r\n        -- Air below (or we just dug it). Plant.\r\n        logger.info(\"Planting potato below...\")\r\n        \r\n        -- Find and select potato\r\n        local foundPotato = false\r\n        for i = 1, 16 do\r\n            local item = turtle.getItemDetail(i)\r\n            if item and item.name == \"minecraft:potato\" then\r\n                turtle.select(i)\r\n                foundPotato = true\r\n                break\r\n            end\r\n        end\r\n\r\n        if foundPotato then\r\n            if not turtle.placeDown() then\r\n                 logger.warn(\"Failed to plant (Blocked?)\")\r\n            end\r\n        else\r\n            logger.warn(\"No potatoes to plant!\")\r\n        end\r\n    end\r\n\r\n    -- 4. Move forward\r\n    if not movement.forward() then\r\n        logger.warn(\"Movement blocked! Turning...\")\r\n        -- Simple obstacle avoidance: Turn right and try to move\r\n        movement.turnRight()\r\n        if not movement.forward() then\r\n             logger.warn(\"Still blocked after turning.\")\r\n        end\r\n    end\r\nend\r\n\r\nreturn potato\r\n",
    ["turtleos/strategies/farmer/tree.lua"] = "-- turtleos/strategies/farmer/tree.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\n-- Load movement API\r\nos.loadAPI(\"turtleos/apis/movement.lua\")\r\n\r\nlocal tree = {}\r\n\r\nfunction tree.execute()\r\n    logger.info(\"Farming trees...\")\r\n    local hasBlock, data = turtle.inspect()\r\n    \r\n    if hasBlock and (data.name == \"minecraft:log\" or data.name == \"minecraft:oak_log\") then\r\n        logger.info(\"Chopping tree...\")\r\n        turtle.dig()\r\n        movement.forward(true)  -- Use movement API with force\r\n        -- Logic to chop up and come down would go here\r\n        movement.back()\r\n    elseif not hasBlock then\r\n        logger.info(\"Planting sapling...\")\r\n        turtle.place()\r\n    end\r\n    \r\n    -- Log current position\r\n    local pos = movement.getPosition()\r\n    logger.info(string.format(\"Position: %d, %d, %d\", pos.x, pos.y, pos.z))\r\nend\r\n\r\nreturn tree\r\n",
}

for path, content in pairs(files) do
    print("Writing " .. path)
    local dir = fs.getDir(path)
    if not fs.exists(dir) and dir ~= "" and dir ~= "." then
        fs.makeDir(dir)
    end
    
    local file = fs.open(path, "w")
    file.write(content)
    file.close()
end

if not fs.exists("startup.lua") then
    print("Creating startup.lua...")
    local file = fs.open("startup.lua", "w")
    file.write('shell.run("boot.lua")')
    file.close()
end

print("Installation complete. Rebooting in 3 seconds...")
sleep(3)
os.reboot()
