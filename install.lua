-- TurtleOS Installer
print('Installing TurtleOS...')

-- Wipe drive (except for this installer and rom)
print("Wiping drive...")
local runningProgram = shell.getRunningProgram()
local allFiles = fs.list("/")
for _, file in ipairs(allFiles) do
    if file ~= "rom" and file ~= runningProgram then
        print("Deleting " .. file)
        fs.delete(file)
    end
end

local files = {
    ['boot.lua'] = "-- boot.lua\r\n-- This file should be renamed to startup.lua on the turtle or called by it.\r\n\r\n-- Add the root directory to the package path so we can require files relative to root\r\npackage.path = \"/?.lua;/?/init.lua;\" .. package.path\r\n\r\n-- Load APIs\r\nif fs.exists(\"turtleos/apis/movement.lua\") then\r\n    os.loadAPI(\"turtleos/apis/movement.lua\")\r\nend\r\n\r\nlocal core = require(\"turtleos.lib.core\")\r\n\r\nprint(\"Booting TurtleOS...\")\r\ncore.init()\r\n",
    ['turtleos/lib/core.lua'] = "-- turtleos/lib/core.lua\r\nlocal schema = require(\"turtleos.lib.schema\")\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal core = {}\r\n\r\nfunction core.init()\r\n    logger.info(\"TurtleOS initializing...\")\r\n    \r\n    -- Load schema\r\n    local schemaData, err = schema.load(\"turtle_schema.json\")\r\n    if not schemaData then\r\n        logger.error(\"Failed to load schema: \" .. (err or \"unknown error\"))\r\n        return false\r\n    end\r\n\r\n    logger.info(\"Loaded schema for: \" .. (schemaData.name or \"Unknown Turtle\"))\r\n\r\n    -- Determine role\r\n    local role = schemaData.role\r\n    if not role then\r\n        logger.error(\"No role defined in schema\")\r\n        return false\r\n    end\r\n\r\n    logger.info(\"Role: \" .. role)\r\n\r\n    -- Load role module\r\n    local rolePath = \"turtleos.roles.\" .. role\r\n    local success, roleModule = pcall(require, rolePath)\r\n    \r\n    if not success then\r\n        logger.error(\"Failed to load role module: \" .. rolePath)\r\n        logger.error(roleModule) -- Error message\r\n        return false\r\n    end\r\n\r\n    -- Execute role\r\n    if roleModule.run then\r\n        roleModule.run(schemaData)\r\n    else\r\n        logger.error(\"Role module missing 'run' function\")\r\n        return false\r\n    end\r\n\r\n    return true\r\nend\r\n\r\nreturn core\r\n",
    ['turtleos/lib/logger.lua'] = "-- turtleos/lib/logger.lua\r\n\r\nlocal logger = {}\r\n\r\nfunction logger.log(message)\r\n    print(\"[LOG] \" .. message)\r\n    -- In a real implementation, we might write to a file\r\nend\r\n\r\nfunction logger.error(message)\r\n    printError(\"[ERROR] \" .. message)\r\nend\r\n\r\nfunction logger.info(message)\r\n    print(\"[INFO] \" .. message)\r\nend\r\n\r\nreturn logger\r\n",
    ['turtleos/lib/schema.lua'] = "-- turtleos/lib/schema.lua\r\n\r\nlocal schema = {}\r\n\r\nfunction schema.load(path)\r\n    if not fs.exists(path) then\r\n        return nil, \"Schema file not found: \" .. path\r\n    end\r\n\r\n    local file = fs.open(path, \"r\")\r\n    local content = file.readAll()\r\n    file.close()\r\n\r\n    local data = textutils.unserializeJSON(content)\r\n    if not data then\r\n        return nil, \"Failed to parse schema JSON\"\r\n    end\r\n\r\n    return data\r\nend\r\n\r\nreturn schema\r\n",
    ['turtleos/roles/builder.lua'] = "-- turtleos/roles/builder.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal builder = {}\r\n\r\nfunction builder.run(schema)\r\n    logger.info(\"Starting Builder Role...\")\r\n    -- Builder logic here\r\n    -- Might load a blueprint from schema\r\nend\r\n\r\nreturn builder\r\n",
    ['turtleos/roles/farmer.lua'] = "-- turtleos/roles/farmer.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal farmer = {}\r\n\r\nfunction farmer.run(schema)\r\n    logger.info(\"Starting Farmer Role...\")\r\n    \r\n    local strategyName = schema.strategy\r\n    if not strategyName then\r\n        logger.error(\"No strategy defined for Farmer\")\r\n        return\r\n    end\r\n\r\n    local strategyPath = \"turtleos.strategies.farmer.\" .. strategyName\r\n    local success, strategy = pcall(require, strategyPath)\r\n\r\n    if not success then\r\n        logger.error(\"Failed to load strategy: \" .. strategyPath)\r\n        logger.error(strategy)\r\n        return\r\n    end\r\n\r\n    logger.info(\"Executing strategy: \" .. strategyName)\r\n    \r\n    while true do\r\n        if strategy.execute then\r\n            strategy.execute()\r\n        else\r\n            logger.error(\"Strategy missing 'execute' function\")\r\n            break\r\n        end\r\n        sleep(1) -- Prevent infinite loop crash if strategy is instant\r\n    end\r\nend\r\n\r\nreturn farmer\r\n",
    ['turtleos/roles/miner.lua'] = "-- turtleos/roles/miner.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal miner = {}\r\n\r\nfunction miner.run(schema)\r\n    logger.info(\"Starting Miner Role...\")\r\n    -- Miner logic here\r\nend\r\n\r\nreturn miner\r\n",
    ['turtleos/strategies/farmer/potato.lua'] = "-- turtleos/strategies/farmer/potato.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\nlocal potato = {}\r\n\r\nfunction potato.execute()\r\n    logger.info(\"Farming potatoes...\")\r\n    -- Check block in front\r\n    local hasBlock, data = turtle.inspect()\r\n    if hasBlock and data.name == \"minecraft:potatoes\" and data.state.age == 7 then\r\n        logger.info(\"Harvesting potato...\")\r\n        turtle.dig()\r\n        turtle.suck() -- Pick up drops\r\n        turtle.place() -- Replant (assuming potato in slot 1)\r\n    elseif not hasBlock then\r\n        logger.info(\"Planting potato...\")\r\n        turtle.place()\r\n    else\r\n        logger.info(\"Waiting for potato to grow...\")\r\n    end\r\nend\r\n\r\nreturn potato\r\n",
    ['turtleos/apis/movement.lua'] = "-- turtleos/apis/movement.lua\r\n-- Movement State Machine API for ComputerCraft Turtles\r\n-- Load with: os.loadAPI(\"turtleos/apis/movement.lua\")\r\n-- Access via: movement.forward(), movement.getPosition(), etc.\r\n\r\n-- State tracking\r\nlocal position = {x = 0, y = 0, z = 0}\r\nlocal facing = 0  -- 0=North(+Z), 1=East(+X), 2=South(-Z), 3=West(-X)\r\nlocal moveAttempts = 3\r\nlocal fuelThreshold = 100\r\n\r\n-- Movement states\r\nlocal STATE = {\r\n    IDLE = \"idle\",\r\n    MOVING = \"moving\",\r\n    BLOCKED = \"blocked\",\r\n    ATTACKING = \"attacking\",\r\n    LOW_FUEL = \"low_fuel\"\r\n}\r\n\r\nlocal currentState = STATE.IDLE\r\n\r\n-- Direction vectors for each facing\r\nlocal DIRECTIONS = {\r\n    [0] = {x = 0, z = 1},   -- North\r\n    [1] = {x = 1, z = 0},   -- East\r\n    [2] = {x = 0, z = -1},  -- South\r\n    [3] = {x = -1, z = 0}   -- West\r\n}\r\n\r\n-- Get current position\r\nfunction getPosition()\r\n    return {x = position.x, y = position.y, z = position.z}\r\nend\r\n\r\n-- Get current facing direction\r\nfunction getFacing()\r\n    return facing\r\nend\r\n\r\n-- Get current state\r\nfunction getState()\r\n    return currentState\r\nend\r\n\r\n-- Set position (useful for calibration)\r\nfunction setPosition(x, y, z)\r\n    position.x = x or position.x\r\n    position.y = y or position.y\r\n    position.z = z or position.z\r\nend\r\n\r\n-- Set facing direction\r\nfunction setFacing(dir)\r\n    facing = dir % 4\r\nend\r\n\r\n-- Check fuel level\r\nfunction checkFuel()\r\n    local level = turtle.getFuelLevel()\r\n    if level == \"unlimited\" then\r\n        return true\r\n    end\r\n    \r\n    if level < fuelThreshold then\r\n        currentState = STATE.LOW_FUEL\r\n        return false\r\n    end\r\n    return true\r\nend\r\n\r\n-- Try to refuel from inventory\r\nfunction refuel(amount)\r\n    amount = amount or 64\r\n    for slot = 1, 16 do\r\n        if turtle.getItemCount(slot) > 0 then\r\n            turtle.select(slot)\r\n            if turtle.refuel(1) then\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn right\r\nfunction turnRight()\r\n    if turtle.turnRight() then\r\n        facing = (facing + 1) % 4\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn left\r\nfunction turnLeft()\r\n    if turtle.turnLeft() then\r\n        facing = (facing - 1) % 4\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Turn around\r\nfunction turnAround()\r\n    turnRight()\r\n    turnRight()\r\n    return true\r\nend\r\n\r\n-- Face a specific direction (0-3)\r\nfunction face(dir)\r\n    dir = dir % 4\r\n    while facing ~= dir do\r\n        turnRight()\r\n    end\r\n    return true\r\nend\r\n\r\n-- Forward movement with retry logic\r\nfunction forward(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.forward() then\r\n            -- Update position\r\n            local dir = DIRECTIONS[facing]\r\n            position.x = position.x + dir.x\r\n            position.z = position.z + dir.z\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            -- Try to clear the way\r\n            if turtle.detect() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.dig()\r\n                sleep(0.5)\r\n            elseif turtle.attack() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Backward movement\r\nfunction back()\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    \r\n    if turtle.back() then\r\n        -- Update position (move opposite of facing)\r\n        local dir = DIRECTIONS[facing]\r\n        position.x = position.x - dir.x\r\n        position.z = position.z - dir.z\r\n        currentState = STATE.IDLE\r\n        return true\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Up movement with retry logic\r\nfunction up(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.up() then\r\n            position.y = position.y + 1\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectUp() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digUp()\r\n                sleep(0.5)\r\n            elseif turtle.attackUp() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Down movement with retry logic\r\nfunction down(force)\r\n    if not checkFuel() then\r\n        return false, \"low_fuel\"\r\n    end\r\n    \r\n    currentState = STATE.MOVING\r\n    local attempts = 0\r\n    \r\n    while attempts < moveAttempts do\r\n        if turtle.down() then\r\n            position.y = position.y - 1\r\n            currentState = STATE.IDLE\r\n            return true\r\n        end\r\n        \r\n        attempts = attempts + 1\r\n        \r\n        if force and attempts < moveAttempts then\r\n            if turtle.detectDown() then\r\n                currentState = STATE.BLOCKED\r\n                turtle.digDown()\r\n                sleep(0.5)\r\n            elseif turtle.attackDown() then\r\n                currentState = STATE.ATTACKING\r\n                sleep(0.5)\r\n            end\r\n        else\r\n            sleep(0.2)\r\n        end\r\n    end\r\n    \r\n    currentState = STATE.BLOCKED\r\n    return false, \"blocked\"\r\nend\r\n\r\n-- Go to a specific position (simple pathfinding)\r\nfunction gotoPosition(targetX, targetY, targetZ, force)\r\n    force = force or false\r\n    \r\n    -- Move in X axis\r\n    while position.x ~= targetX do\r\n        if position.x < targetX then\r\n            face(1)  -- East\r\n        else\r\n            face(3)  -- West\r\n        end\r\n        \r\n        local success, err = forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Z axis\r\n    while position.z ~= targetZ do\r\n        if position.z < targetZ then\r\n            face(0)  -- North\r\n        else\r\n            face(2)  -- South\r\n        end\r\n        \r\n        local success, err = forward(force)\r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    -- Move in Y axis\r\n    while position.y ~= targetY do\r\n        local success, err\r\n        if position.y < targetY then\r\n            success, err = up(force)\r\n        else\r\n            success, err = down(force)\r\n        end\r\n        \r\n        if not success then\r\n            return false, err\r\n        end\r\n    end\r\n    \r\n    return true\r\nend\r\n\r\n-- Return to origin (0, 0, 0)\r\nfunction home(force)\r\n    return gotoPosition(0, 0, 0, force)\r\nend\r\n\r\n-- Get distance to a position\r\nfunction distanceTo(x, y, z)\r\n    local dx = math.abs(position.x - x)\r\n    local dy = math.abs(position.y - y)\r\n    local dz = math.abs(position.z - z)\r\n    return dx + dy + dz  -- Manhattan distance\r\nend\r\n\r\n-- Configure movement parameters\r\nfunction configure(config)\r\n    if config.moveAttempts then\r\n        moveAttempts = config.moveAttempts\r\n    end\r\n    if config.fuelThreshold then\r\n        fuelThreshold = config.fuelThreshold\r\n    end\r\nend\r\n\r\n-- Reset position and facing\r\nfunction reset()\r\n    position = {x = 0, y = 0, z = 0}\r\n    facing = 0\r\n    currentState = STATE.IDLE\r\nend\r\n\r\n-- Save state to file\r\nfunction saveState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    local file = fs.open(filename, \"w\")\r\n    if file then\r\n        file.writeLine(textutils.serialize({\r\n            position = position,\r\n            facing = facing\r\n        }))\r\n        file.close()\r\n        return true\r\n    end\r\n    return false\r\nend\r\n\r\n-- Load state from file\r\nfunction loadState(filename)\r\n    filename = filename or \"movement_state.txt\"\r\n    if fs.exists(filename) then\r\n        local file = fs.open(filename, \"r\")\r\n        if file then\r\n            local data = textutils.unserialize(file.readAll())\r\n            file.close()\r\n            if data then\r\n                position = data.position or {x = 0, y = 0, z = 0}\r\n                facing = data.facing or 0\r\n                return true\r\n            end\r\n        end\r\n    end\r\n    return false\r\nend\r\n",
    ['turtleos/strategies/farmer/tree.lua'] = "-- turtleos/strategies/farmer/tree.lua\r\nlocal logger = require(\"turtleos.lib.logger\")\r\n\r\n-- Load movement API\r\nos.loadAPI(\"turtleos/apis/movement.lua\")\r\n\r\nlocal tree = {}\r\n\r\nfunction tree.execute()\r\n    logger.info(\"Farming trees...\")\r\n    local hasBlock, data = turtle.inspect()\r\n    \r\n    if hasBlock and (data.name == \"minecraft:log\" or data.name == \"minecraft:oak_log\") then\r\n        logger.info(\"Chopping tree...\")\r\n        turtle.dig()\r\n        movement.forward(true)  -- Use movement API with force\r\n        -- Logic to chop up and come down would go here\r\n        movement.back()\r\n    elseif not hasBlock then\r\n        logger.info(\"Planting sapling...\")\r\n        turtle.place()\r\n    end\r\n    \r\n    -- Log current position\r\n    local pos = movement.getPosition()\r\n    logger.info(string.format(\"Position: %d, %d, %d\", pos.x, pos.y, pos.z))\r\nend\r\n\r\nreturn tree\r\n",
}

for path, content in pairs(files) do
    print("Writing " .. path)
    local dir = fs.getDir(path)
    if not fs.exists(dir) and dir ~= "" and dir ~= "." then
        fs.makeDir(dir)
    end
    
    local file = fs.open(path, "w")
    file.write(content)
    file.close()
end

if not fs.exists("startup.lua") then
    print("Creating startup.lua...")
    local file = fs.open("startup.lua", "w")
    file.write('shell.run("boot.lua")')
    file.close()
end

print("Installation complete. Rebooting in 3 seconds...")
sleep(3)
os.reboot()